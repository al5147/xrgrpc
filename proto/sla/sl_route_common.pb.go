// @file
// @brief Client RPC proto file for common route types.
// This file defines common route features, including the Prefix,
// VRF information, path information, administrative distance, and
// default route status for a route object.
//
// ----------------------------------------------------------------
//  Copyright (c) 2016 by Cisco Systems, Inc.
//  All rights reserved.
// -----------------------------------------------------------------
//
//

//@defgroup Route
//@brief Route service definitions.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.0
// 	protoc        v3.5.0
// source: sl_route_common.proto

package service_layer

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Route Globals Get Message
type SLRouteGlobalsGetMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SLRouteGlobalsGetMsg) Reset() {
	*x = SLRouteGlobalsGetMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRouteGlobalsGetMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRouteGlobalsGetMsg) ProtoMessage() {}

func (x *SLRouteGlobalsGetMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRouteGlobalsGetMsg.ProtoReflect.Descriptor instead.
func (*SLRouteGlobalsGetMsg) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{0}
}

// Route Globals Get Message Response
type SLRouteGlobalsGetMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Max VrfReg objects within a single VrfRegMsg message.
	MaxVrfregPerVrfregmsg uint32 `protobuf:"varint,2,opt,name=MaxVrfregPerVrfregmsg,proto3" json:"MaxVrfregPerVrfregmsg,omitempty"`
	// Max Route objects within a single RouteMsg message.
	MaxRoutePerRoutemsg uint32 `protobuf:"varint,3,opt,name=MaxRoutePerRoutemsg,proto3" json:"MaxRoutePerRoutemsg,omitempty"`
}

func (x *SLRouteGlobalsGetMsgRsp) Reset() {
	*x = SLRouteGlobalsGetMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRouteGlobalsGetMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRouteGlobalsGetMsgRsp) ProtoMessage() {}

func (x *SLRouteGlobalsGetMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRouteGlobalsGetMsgRsp.ProtoReflect.Descriptor instead.
func (*SLRouteGlobalsGetMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{1}
}

func (x *SLRouteGlobalsGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLRouteGlobalsGetMsgRsp) GetMaxVrfregPerVrfregmsg() uint32 {
	if x != nil {
		return x.MaxVrfregPerVrfregmsg
	}
	return 0
}

func (x *SLRouteGlobalsGetMsgRsp) GetMaxRoutePerRoutemsg() uint32 {
	if x != nil {
		return x.MaxRoutePerRoutemsg
	}
	return 0
}

// Route Global Stats Get Message
type SLRouteGlobalStatsGetMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *SLRouteGlobalStatsGetMsg) Reset() {
	*x = SLRouteGlobalStatsGetMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRouteGlobalStatsGetMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRouteGlobalStatsGetMsg) ProtoMessage() {}

func (x *SLRouteGlobalStatsGetMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRouteGlobalStatsGetMsg.ProtoReflect.Descriptor instead.
func (*SLRouteGlobalStatsGetMsg) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{2}
}

// Route Global Stats Get Message Response
type SLRouteGlobalStatsGetMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Num VRFs registered through the service layer.
	VrfCount uint32 `protobuf:"varint,2,opt,name=VrfCount,proto3" json:"VrfCount,omitempty"`
	// Num Routes added through the service layer.
	RouteCount uint32 `protobuf:"varint,3,opt,name=RouteCount,proto3" json:"RouteCount,omitempty"`
}

func (x *SLRouteGlobalStatsGetMsgRsp) Reset() {
	*x = SLRouteGlobalStatsGetMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRouteGlobalStatsGetMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRouteGlobalStatsGetMsgRsp) ProtoMessage() {}

func (x *SLRouteGlobalStatsGetMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRouteGlobalStatsGetMsgRsp.ProtoReflect.Descriptor instead.
func (*SLRouteGlobalStatsGetMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{3}
}

func (x *SLRouteGlobalStatsGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLRouteGlobalStatsGetMsgRsp) GetVrfCount() uint32 {
	if x != nil {
		return x.VrfCount
	}
	return 0
}

func (x *SLRouteGlobalStatsGetMsgRsp) GetRouteCount() uint32 {
	if x != nil {
		return x.RouteCount
	}
	return 0
}

// VRF Registration message
type SLVrfReg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// VRF Name.
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Default Admin distance for routes programmed by this application
	// Range [0-255]
	// This default value is used if route objects' AdminDistance is 0.
	// Refer to SLRouteCommon
	AdminDistance uint32 `protobuf:"varint,2,opt,name=AdminDistance,proto3" json:"AdminDistance,omitempty"`
	// In case the Service Layer -> RIB connection is lost, this specifies the
	// timeout period after which RIB will automatically purge the installed
	// routes, unless the service layer:
	//    1. Re-registers (VRF)
	//    2. Replay all routes
	//    3. And send EOF, before the purge timeout
	VrfPurgeIntervalSeconds uint32 `protobuf:"varint,3,opt,name=VrfPurgeIntervalSeconds,proto3" json:"VrfPurgeIntervalSeconds,omitempty"`
}

func (x *SLVrfReg) Reset() {
	*x = SLVrfReg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVrfReg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVrfReg) ProtoMessage() {}

func (x *SLVrfReg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVrfReg.ProtoReflect.Descriptor instead.
func (*SLVrfReg) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{4}
}

func (x *SLVrfReg) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLVrfReg) GetAdminDistance() uint32 {
	if x != nil {
		return x.AdminDistance
	}
	return 0
}

func (x *SLVrfReg) GetVrfPurgeIntervalSeconds() uint32 {
	if x != nil {
		return x.VrfPurgeIntervalSeconds
	}
	return 0
}

// VRF Registration messages.
type SLVrfRegMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Registration Operation
	Oper SLRegOp `protobuf:"varint,1,opt,name=Oper,proto3,enum=SLRegOp" json:"Oper,omitempty"`
	// List of VRF registrations
	VrfRegMsgs []*SLVrfReg `protobuf:"bytes,2,rep,name=VrfRegMsgs,proto3" json:"VrfRegMsgs,omitempty"`
}

func (x *SLVrfRegMsg) Reset() {
	*x = SLVrfRegMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVrfRegMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVrfRegMsg) ProtoMessage() {}

func (x *SLVrfRegMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVrfRegMsg.ProtoReflect.Descriptor instead.
func (*SLVrfRegMsg) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{5}
}

func (x *SLVrfRegMsg) GetOper() SLRegOp {
	if x != nil {
		return x.Oper
	}
	return SLRegOp_SL_REGOP_RESERVED
}

func (x *SLVrfRegMsg) GetVrfRegMsgs() []*SLVrfReg {
	if x != nil {
		return x.VrfRegMsgs
	}
	return nil
}

// VRF Registration message Result
type SLVrfRegMsgRes struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Corresponding error code
	ErrStatus *SLErrorStatus `protobuf:"bytes,1,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// VRF Name
	VrfName string `protobuf:"bytes,2,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
}

func (x *SLVrfRegMsgRes) Reset() {
	*x = SLVrfRegMsgRes{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVrfRegMsgRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVrfRegMsgRes) ProtoMessage() {}

func (x *SLVrfRegMsgRes) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVrfRegMsgRes.ProtoReflect.Descriptor instead.
func (*SLVrfRegMsgRes) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{6}
}

func (x *SLVrfRegMsgRes) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLVrfRegMsgRes) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

// VRF Registration message Response.
type SLVrfRegMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Summary result of the bulk operation (refer to enum SLErrorStatus)
	// In general, the StatusSummary implies one of 3 things:
	// 1. SL_SUCCESS: signifies that the entire bulk operation was successful.
	//         In this case, the Results list is empty.
	// 2. SL_SOME_ERR: signifies that the operation failed for one or more
	//         entries. In this case, Results holds the result for
	//         each individual entry in the bulk.
	// 3. SL_RPC_XXX: signifies that the entire bulk operation failed.
	//         In this case, the Results list is empty.
	StatusSummary *SLErrorStatus `protobuf:"bytes,1,opt,name=StatusSummary,proto3" json:"StatusSummary,omitempty"`
	// In case of errors, this field indicates which entry in the bulk was
	// erroneous.
	Results []*SLVrfRegMsgRes `protobuf:"bytes,2,rep,name=Results,proto3" json:"Results,omitempty"`
}

func (x *SLVrfRegMsgRsp) Reset() {
	*x = SLVrfRegMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVrfRegMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVrfRegMsgRsp) ProtoMessage() {}

func (x *SLVrfRegMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVrfRegMsgRsp.ProtoReflect.Descriptor instead.
func (*SLVrfRegMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{7}
}

func (x *SLVrfRegMsgRsp) GetStatusSummary() *SLErrorStatus {
	if x != nil {
		return x.StatusSummary
	}
	return nil
}

func (x *SLVrfRegMsgRsp) GetResults() []*SLVrfRegMsgRes {
	if x != nil {
		return x.Results
	}
	return nil
}

// VRF Get Message
type SLVrfRegGetMsg struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// VRF name (key).
	// If the Key is not specified, then request up to the first
	// 'EntriesCount' entries.
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Number of entries requested
	EntriesCount uint32 `protobuf:"varint,2,opt,name=EntriesCount,proto3" json:"EntriesCount,omitempty"`
	// if GetNext is FALSE:
	//     request up to 'EntriesCount' entries starting from the key
	// If GetNext is TRUE, or if the key exact match is not found:
	//     request up to 'EntriesCount' entries starting from the key's next
	GetNext bool `protobuf:"varint,3,opt,name=GetNext,proto3" json:"GetNext,omitempty"`
}

func (x *SLVrfRegGetMsg) Reset() {
	*x = SLVrfRegGetMsg{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVrfRegGetMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVrfRegGetMsg) ProtoMessage() {}

func (x *SLVrfRegGetMsg) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVrfRegGetMsg.ProtoReflect.Descriptor instead.
func (*SLVrfRegGetMsg) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{8}
}

func (x *SLVrfRegGetMsg) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLVrfRegGetMsg) GetEntriesCount() uint32 {
	if x != nil {
		return x.EntriesCount
	}
	return 0
}

func (x *SLVrfRegGetMsg) GetGetNext() bool {
	if x != nil {
		return x.GetNext
	}
	return false
}

// VRF Get Message Response
type SLVrfRegGetMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,1,opt,name=Eof,proto3" json:"Eof,omitempty"`
	// Status of the Get operation
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries []*SLVrfReg `protobuf:"bytes,3,rep,name=Entries,proto3" json:"Entries,omitempty"`
}

func (x *SLVrfRegGetMsgRsp) Reset() {
	*x = SLVrfRegGetMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVrfRegGetMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVrfRegGetMsgRsp) ProtoMessage() {}

func (x *SLVrfRegGetMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVrfRegGetMsgRsp.ProtoReflect.Descriptor instead.
func (*SLVrfRegGetMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{9}
}

func (x *SLVrfRegGetMsgRsp) GetEof() bool {
	if x != nil {
		return x.Eof
	}
	return false
}

func (x *SLVrfRegGetMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLVrfRegGetMsgRsp) GetEntries() []*SLVrfReg {
	if x != nil {
		return x.Entries
	}
	return nil
}

// VRF Get Stats Message Response
type SLVRFGetStatsMsgRes struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// VRF name as key
	VrfName string `protobuf:"bytes,1,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Num VRF Routes added through the service layer.
	RouteCount uint32 `protobuf:"varint,2,opt,name=RouteCount,proto3" json:"RouteCount,omitempty"`
}

func (x *SLVRFGetStatsMsgRes) Reset() {
	*x = SLVRFGetStatsMsgRes{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVRFGetStatsMsgRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVRFGetStatsMsgRes) ProtoMessage() {}

func (x *SLVRFGetStatsMsgRes) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVRFGetStatsMsgRes.ProtoReflect.Descriptor instead.
func (*SLVRFGetStatsMsgRes) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{10}
}

func (x *SLVRFGetStatsMsgRes) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLVRFGetStatsMsgRes) GetRouteCount() uint32 {
	if x != nil {
		return x.RouteCount
	}
	return 0
}

// VRF Get Stats Message Response
type SLVRFGetStatsMsgRsp struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// End Of File.
	// When set to True, it indicates that the server has returned M, where
	// M < N, of the original N requested Entries.
	Eof bool `protobuf:"varint,1,opt,name=Eof,proto3" json:"Eof,omitempty"`
	// Status of the Get Stats operation
	ErrStatus *SLErrorStatus `protobuf:"bytes,2,opt,name=ErrStatus,proto3" json:"ErrStatus,omitempty"`
	// Returned entries as requested in the Get Stats operation.
	// if ErrStatus is SL_SUCCESS, Entries contains the info requested
	Entries []*SLVRFGetStatsMsgRes `protobuf:"bytes,3,rep,name=Entries,proto3" json:"Entries,omitempty"`
}

func (x *SLVRFGetStatsMsgRsp) Reset() {
	*x = SLVRFGetStatsMsgRsp{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLVRFGetStatsMsgRsp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLVRFGetStatsMsgRsp) ProtoMessage() {}

func (x *SLVRFGetStatsMsgRsp) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLVRFGetStatsMsgRsp.ProtoReflect.Descriptor instead.
func (*SLVRFGetStatsMsgRsp) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{11}
}

func (x *SLVRFGetStatsMsgRsp) GetEof() bool {
	if x != nil {
		return x.Eof
	}
	return false
}

func (x *SLVRFGetStatsMsgRsp) GetErrStatus() *SLErrorStatus {
	if x != nil {
		return x.ErrStatus
	}
	return nil
}

func (x *SLVRFGetStatsMsgRsp) GetEntries() []*SLVRFGetStatsMsgRes {
	if x != nil {
		return x.Entries
	}
	return nil
}

// Common IPv4/IPv6 route attributes.
type SLRouteCommon struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Adminstrative distance of the route. [0-255].
	// RIB uses this field to break the tie when multiple
	// sources install the same route.
	// Lower distance is preferred over higher distance.
	// The per route object admin distance overrides the default's admin
	// distance set at VRF registration. see SLVrfReg
	AdminDistance uint32 `protobuf:"varint,1,opt,name=AdminDistance,proto3" json:"AdminDistance,omitempty"`
	// Local label associated with this route.
	// This is an optional field that can be used to simulatenously setup an
	// ILM entry (e.g. head end of an MPLS LSP) for the same route.
	// This is especially useful when setting up an MPLS LSP (a /32-route
	// towards the remote LSP peer e.g. 2.2.2.2/32) which is required for MPLS
	// VPN labeled routes.
	//
	// Note: MPLS VPN labeled routes can resolve only on:
	//    - /32-routes with valid LocalLabel and a valid egress MPLS path label
	LocalLabel uint32 `protobuf:"varint,2,opt,name=LocalLabel,proto3" json:"LocalLabel,omitempty"`
	// Route Tag.
	// Routes are usually tagged to prevent loops during redistribution between
	// protocols.
	Tag uint32 `protobuf:"varint,3,opt,name=Tag,proto3" json:"Tag,omitempty"`
}

func (x *SLRouteCommon) Reset() {
	*x = SLRouteCommon{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRouteCommon) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRouteCommon) ProtoMessage() {}

func (x *SLRouteCommon) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRouteCommon.ProtoReflect.Descriptor instead.
func (*SLRouteCommon) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{12}
}

func (x *SLRouteCommon) GetAdminDistance() uint32 {
	if x != nil {
		return x.AdminDistance
	}
	return 0
}

func (x *SLRouteCommon) GetLocalLabel() uint32 {
	if x != nil {
		return x.LocalLabel
	}
	return 0
}

func (x *SLRouteCommon) GetTag() uint32 {
	if x != nil {
		return x.Tag
	}
	return 0
}

// Route Path attributes.
//
// FRR Note:
// Failover from primary to backup is based on the trigger used (e.g.
// link down, BFD, etc.). Revertion is mainly timeout based. The timeout
// value is platform specific and is not configurable.
type SLRoutePath struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// One of IPv4 or IPv6 address
	NexthopAddress *SLIpAddress `protobuf:"bytes,1,opt,name=NexthopAddress,proto3" json:"NexthopAddress,omitempty"`
	// Outgoing interface name for the path.
	NexthopInterface *SLInterface `protobuf:"bytes,2,opt,name=NexthopInterface,proto3" json:"NexthopInterface,omitempty"`
	// Load metric for this path.
	// Used for equal/unequal cost load balancing of traffic distribution.
	LoadMetric uint32 `protobuf:"varint,3,opt,name=LoadMetric,proto3" json:"LoadMetric,omitempty"`
	// Path VRF name. This field is used ONLY if the path is in a different
	// VRF than the route (e.g. VPN cases)
	VrfName string `protobuf:"bytes,4,opt,name=VrfName,proto3" json:"VrfName,omitempty"`
	// Route Metric.
	// The metric is typically based on information like load, hop count,
	// MTU, reliability of the path, etc.
	Metric uint32 `protobuf:"varint,5,opt,name=Metric,proto3" json:"Metric,omitempty"`
	// Path identifier.
	// Path-id is used to uniquely identify a path when it comes to
	// protection (Fast Re-Route - FRR). It is not used otherwise.
	//
	// In general, for FRR, There are 3 main path attributes:
	//    1. Primary. The path is the main path to carry traffic.
	//    2. Protected. A primary path with a configured backup path.
	//    3. Backup. The path is protecting a primary path.
	//
	// NOTE1: a primary path (A) can be simultaneously protected (by B), and
	// acting as a backup for another path (C).
	// In this example, the primary path C is protected by A (which happens to
	// be primary). So the primary path (A) is Primary, Protected, and Backup.
	//
	// The following are various path types based on combinations of attributes:
	//    1. Pure Primary i.e. Not Protected and is not a Backup.
	//       => PathId is optional. ProtectedPathBitmap = 0x0
	//    2. Primary and Protected. Path is not a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0x0
	//    3. Primary and Not Protected. Path is also a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//    4. Primary and Protected. Path is also a Backup.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//    5. Pure Backup. Protection is not allowed for backup paths.
	//       => PathId is mandatory. ProtectedPathBitmap = 0xYYYY
	//
	// NOTE2: Pure backup path-id uses a different range than primary path-ids.
	// The valid range of primary path IDs, and pure backup path IDS are
	// platform dependent and can be retrieved through the client init message.
	PathId uint32 `protobuf:"varint,6,opt,name=PathId,proto3" json:"PathId,omitempty"`
	// Path protection bitmap.
	// The bitmap of paths this Backup path is protecting.
	// Example: If this path is protecting paths with IDs 4, 5 and 6, then
	// set bitmap to:
	// 0x38 ==> 0011 1000
	//            || |-- path 4
	//            ||-- path 5
	//            |-- path 6
	// (1 << (pathId_1 - 1))  | (1 << (pathId_2 - 1)) | (1 << (pathId_3 - 1))
	ProtectedPathBitmap []uint64 `protobuf:"varint,7,rep,packed,name=ProtectedPathBitmap,proto3" json:"ProtectedPathBitmap,omitempty"`
	// MPLS label stack.
	// Stack of labels that is pushed when the packet is switched out.
	// Label size is LSB 20 bits. Forwarding will set EXP, TTL and BOS.
	// For primary path, typically only 1 label is used.
	// For backup paths, more than 1 label can be used. If more than one label
	// is used, remote backup addresses must be specified.
	// The maximum number of labels pushed for primary and backup are
	// platform dependent.
	LabelStack []uint32 `protobuf:"varint,8,rep,packed,name=LabelStack,proto3" json:"LabelStack,omitempty"`
	// MPLS Remote router backup address.
	// This field is used only for backup MPLS path with more than one label
	// For N+1 backup labels, N remote backup addresses must be specified.
	RemoteAddress []*SLIpAddress `protobuf:"bytes,9,rep,name=RemoteAddress,proto3" json:"RemoteAddress,omitempty"`
}

func (x *SLRoutePath) Reset() {
	*x = SLRoutePath{}
	if protoimpl.UnsafeEnabled {
		mi := &file_sl_route_common_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SLRoutePath) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SLRoutePath) ProtoMessage() {}

func (x *SLRoutePath) ProtoReflect() protoreflect.Message {
	mi := &file_sl_route_common_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SLRoutePath.ProtoReflect.Descriptor instead.
func (*SLRoutePath) Descriptor() ([]byte, []int) {
	return file_sl_route_common_proto_rawDescGZIP(), []int{13}
}

func (x *SLRoutePath) GetNexthopAddress() *SLIpAddress {
	if x != nil {
		return x.NexthopAddress
	}
	return nil
}

func (x *SLRoutePath) GetNexthopInterface() *SLInterface {
	if x != nil {
		return x.NexthopInterface
	}
	return nil
}

func (x *SLRoutePath) GetLoadMetric() uint32 {
	if x != nil {
		return x.LoadMetric
	}
	return 0
}

func (x *SLRoutePath) GetVrfName() string {
	if x != nil {
		return x.VrfName
	}
	return ""
}

func (x *SLRoutePath) GetMetric() uint32 {
	if x != nil {
		return x.Metric
	}
	return 0
}

func (x *SLRoutePath) GetPathId() uint32 {
	if x != nil {
		return x.PathId
	}
	return 0
}

func (x *SLRoutePath) GetProtectedPathBitmap() []uint64 {
	if x != nil {
		return x.ProtectedPathBitmap
	}
	return nil
}

func (x *SLRoutePath) GetLabelStack() []uint32 {
	if x != nil {
		return x.LabelStack
	}
	return nil
}

func (x *SLRoutePath) GetRemoteAddress() []*SLIpAddress {
	if x != nil {
		return x.RemoteAddress
	}
	return nil
}

var File_sl_route_common_proto protoreflect.FileDescriptor

var file_sl_route_common_proto_rawDesc = []byte{
	0x0a, 0x15, 0x73, 0x6c, 0x5f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x15, 0x73, 0x6c, 0x5f, 0x63, 0x6f, 0x6d, 0x6d,
	0x6f, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x16,
	0x0a, 0x14, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73,
	0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x22, 0xaf, 0x01, 0x0a, 0x17, 0x53, 0x4c, 0x52, 0x6f, 0x75,
	0x74, 0x65, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x73, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52,
	0x73, 0x70, 0x12, 0x2c, 0x0a, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x12, 0x34, 0x0a, 0x15, 0x4d, 0x61, 0x78, 0x56, 0x72, 0x66, 0x72, 0x65, 0x67, 0x50, 0x65, 0x72,
	0x56, 0x72, 0x66, 0x72, 0x65, 0x67, 0x6d, 0x73, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x15, 0x4d, 0x61, 0x78, 0x56, 0x72, 0x66, 0x72, 0x65, 0x67, 0x50, 0x65, 0x72, 0x56, 0x72, 0x66,
	0x72, 0x65, 0x67, 0x6d, 0x73, 0x67, 0x12, 0x30, 0x0a, 0x13, 0x4d, 0x61, 0x78, 0x52, 0x6f, 0x75,
	0x74, 0x65, 0x50, 0x65, 0x72, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x6d, 0x73, 0x67, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x13, 0x4d, 0x61, 0x78, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x50, 0x65, 0x72,
	0x52, 0x6f, 0x75, 0x74, 0x65, 0x6d, 0x73, 0x67, 0x22, 0x1a, 0x0a, 0x18, 0x53, 0x4c, 0x52, 0x6f,
	0x75, 0x74, 0x65, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x47, 0x65,
	0x74, 0x4d, 0x73, 0x67, 0x22, 0x87, 0x01, 0x0a, 0x1b, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65,
	0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x47, 0x65, 0x74, 0x4d, 0x73,
	0x67, 0x52, 0x73, 0x70, 0x12, 0x2c, 0x0a, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f,
	0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x56, 0x72, 0x66, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x08, 0x56, 0x72, 0x66, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1e,
	0x0a, 0x0a, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x0a, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x22, 0x84,
	0x01, 0x0a, 0x08, 0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x56,
	0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x56, 0x72,
	0x66, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x24, 0x0a, 0x0d, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x44, 0x69,
	0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0d, 0x41, 0x64,
	0x6d, 0x69, 0x6e, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x38, 0x0a, 0x17, 0x56,
	0x72, 0x66, 0x50, 0x75, 0x72, 0x67, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x53,
	0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x17, 0x56, 0x72,
	0x66, 0x50, 0x75, 0x72, 0x67, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x53, 0x65,
	0x63, 0x6f, 0x6e, 0x64, 0x73, 0x22, 0x56, 0x0a, 0x0b, 0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65,
	0x67, 0x4d, 0x73, 0x67, 0x12, 0x1c, 0x0a, 0x04, 0x4f, 0x70, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x08, 0x2e, 0x53, 0x4c, 0x52, 0x65, 0x67, 0x4f, 0x70, 0x52, 0x04, 0x4f, 0x70,
	0x65, 0x72, 0x12, 0x29, 0x0a, 0x0a, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x73,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x09, 0x2e, 0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65,
	0x67, 0x52, 0x0a, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x73, 0x22, 0x58, 0x0a,
	0x0e, 0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x52, 0x65, 0x73, 0x12,
	0x2c, 0x0a, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x52, 0x09, 0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x18, 0x0a,
	0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
	0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0x71, 0x0a, 0x0e, 0x53, 0x4c, 0x56, 0x72, 0x66,
	0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x34, 0x0a, 0x0d, 0x53, 0x74, 0x61,
	0x74, 0x75, 0x73, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x0e, 0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x52, 0x0d, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x53, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x12,
	0x29, 0x0a, 0x07, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x0f, 0x2e, 0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x4d, 0x73, 0x67, 0x52, 0x65,
	0x73, 0x52, 0x07, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x22, 0x68, 0x0a, 0x0e, 0x53, 0x4c,
	0x56, 0x72, 0x66, 0x52, 0x65, 0x67, 0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x12, 0x18, 0x0a, 0x07,
	0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x56,
	0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x22, 0x0a, 0x0c, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65,
	0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x0c, 0x45, 0x6e,
	0x74, 0x72, 0x69, 0x65, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x47, 0x65,
	0x74, 0x4e, 0x65, 0x78, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x47, 0x65, 0x74,
	0x4e, 0x65, 0x78, 0x74, 0x22, 0x78, 0x0a, 0x11, 0x53, 0x4c, 0x56, 0x72, 0x66, 0x52, 0x65, 0x67,
	0x47, 0x65, 0x74, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x10, 0x0a, 0x03, 0x45, 0x6f, 0x66,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x03, 0x45, 0x6f, 0x66, 0x12, 0x2c, 0x0a, 0x09, 0x45,
	0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e,
	0x2e, 0x53, 0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x09,
	0x45, 0x72, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x23, 0x0a, 0x07, 0x45, 0x6e, 0x74,
	0x72, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x09, 0x2e, 0x53, 0x4c, 0x56,
	0x72, 0x66, 0x52, 0x65, 0x67, 0x52, 0x07, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x22, 0x4f,
	0x0a, 0x13, 0x53, 0x4c, 0x56, 0x52, 0x46, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4d,
	0x73, 0x67, 0x52, 0x65, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x12,
	0x1e, 0x0a, 0x0a, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0d, 0x52, 0x0a, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x22,
	0x85, 0x01, 0x0a, 0x13, 0x53, 0x4c, 0x56, 0x52, 0x46, 0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74,
	0x73, 0x4d, 0x73, 0x67, 0x52, 0x73, 0x70, 0x12, 0x10, 0x0a, 0x03, 0x45, 0x6f, 0x66, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x03, 0x45, 0x6f, 0x66, 0x12, 0x2c, 0x0a, 0x09, 0x45, 0x72, 0x72,
	0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x53,
	0x4c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x09, 0x45, 0x72,
	0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x2e, 0x0a, 0x07, 0x45, 0x6e, 0x74, 0x72, 0x69,
	0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x53, 0x4c, 0x56, 0x52, 0x46,
	0x47, 0x65, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4d, 0x73, 0x67, 0x52, 0x65, 0x73, 0x52, 0x07,
	0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x22, 0x67, 0x0a, 0x0d, 0x53, 0x4c, 0x52, 0x6f, 0x75,
	0x74, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x12, 0x24, 0x0a, 0x0d, 0x41, 0x64, 0x6d, 0x69,
	0x6e, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52,
	0x0d, 0x41, 0x64, 0x6d, 0x69, 0x6e, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x1e,
	0x0a, 0x0a, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x0a, 0x4c, 0x6f, 0x63, 0x61, 0x6c, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x12, 0x10,
	0x0a, 0x03, 0x54, 0x61, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x03, 0x54, 0x61, 0x67,
	0x22, 0xed, 0x02, 0x0a, 0x0b, 0x53, 0x4c, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x50, 0x61, 0x74, 0x68,
	0x12, 0x34, 0x0a, 0x0e, 0x4e, 0x65, 0x78, 0x74, 0x68, 0x6f, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65,
	0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x53, 0x4c, 0x49, 0x70, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x0e, 0x4e, 0x65, 0x78, 0x74, 0x68, 0x6f, 0x70, 0x41,
	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x38, 0x0a, 0x10, 0x4e, 0x65, 0x78, 0x74, 0x68, 0x6f,
	0x70, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x0c, 0x2e, 0x53, 0x4c, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x52, 0x10,
	0x4e, 0x65, 0x78, 0x74, 0x68, 0x6f, 0x70, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65,
	0x12, 0x1e, 0x0a, 0x0a, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0d, 0x52, 0x0a, 0x4c, 0x6f, 0x61, 0x64, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63,
	0x12, 0x18, 0x0a, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x07, 0x56, 0x72, 0x66, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x4d, 0x65,
	0x74, 0x72, 0x69, 0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x06, 0x4d, 0x65, 0x74, 0x72,
	0x69, 0x63, 0x12, 0x16, 0x0a, 0x06, 0x50, 0x61, 0x74, 0x68, 0x49, 0x64, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x06, 0x50, 0x61, 0x74, 0x68, 0x49, 0x64, 0x12, 0x30, 0x0a, 0x13, 0x50, 0x72,
	0x6f, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0x50, 0x61, 0x74, 0x68, 0x42, 0x69, 0x74, 0x6d, 0x61,
	0x70, 0x18, 0x07, 0x20, 0x03, 0x28, 0x04, 0x52, 0x13, 0x50, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74,
	0x65, 0x64, 0x50, 0x61, 0x74, 0x68, 0x42, 0x69, 0x74, 0x6d, 0x61, 0x70, 0x12, 0x1e, 0x0a, 0x0a,
	0x4c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x63, 0x6b, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0d,
	0x52, 0x0a, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x63, 0x6b, 0x12, 0x32, 0x0a, 0x0d,
	0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x09, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x53, 0x4c, 0x49, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x52, 0x0d, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x42, 0x11, 0x5a, 0x0f, 0x2e, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x6c, 0x61,
	0x79, 0x65, 0x72, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_sl_route_common_proto_rawDescOnce sync.Once
	file_sl_route_common_proto_rawDescData = file_sl_route_common_proto_rawDesc
)

func file_sl_route_common_proto_rawDescGZIP() []byte {
	file_sl_route_common_proto_rawDescOnce.Do(func() {
		file_sl_route_common_proto_rawDescData = protoimpl.X.CompressGZIP(file_sl_route_common_proto_rawDescData)
	})
	return file_sl_route_common_proto_rawDescData
}

var file_sl_route_common_proto_msgTypes = make([]protoimpl.MessageInfo, 14)
var file_sl_route_common_proto_goTypes = []interface{}{
	(*SLRouteGlobalsGetMsg)(nil),        // 0: SLRouteGlobalsGetMsg
	(*SLRouteGlobalsGetMsgRsp)(nil),     // 1: SLRouteGlobalsGetMsgRsp
	(*SLRouteGlobalStatsGetMsg)(nil),    // 2: SLRouteGlobalStatsGetMsg
	(*SLRouteGlobalStatsGetMsgRsp)(nil), // 3: SLRouteGlobalStatsGetMsgRsp
	(*SLVrfReg)(nil),                    // 4: SLVrfReg
	(*SLVrfRegMsg)(nil),                 // 5: SLVrfRegMsg
	(*SLVrfRegMsgRes)(nil),              // 6: SLVrfRegMsgRes
	(*SLVrfRegMsgRsp)(nil),              // 7: SLVrfRegMsgRsp
	(*SLVrfRegGetMsg)(nil),              // 8: SLVrfRegGetMsg
	(*SLVrfRegGetMsgRsp)(nil),           // 9: SLVrfRegGetMsgRsp
	(*SLVRFGetStatsMsgRes)(nil),         // 10: SLVRFGetStatsMsgRes
	(*SLVRFGetStatsMsgRsp)(nil),         // 11: SLVRFGetStatsMsgRsp
	(*SLRouteCommon)(nil),               // 12: SLRouteCommon
	(*SLRoutePath)(nil),                 // 13: SLRoutePath
	(*SLErrorStatus)(nil),               // 14: SLErrorStatus
	(SLRegOp)(0),                        // 15: SLRegOp
	(*SLIpAddress)(nil),                 // 16: SLIpAddress
	(*SLInterface)(nil),                 // 17: SLInterface
}
var file_sl_route_common_proto_depIdxs = []int32{
	14, // 0: SLRouteGlobalsGetMsgRsp.ErrStatus:type_name -> SLErrorStatus
	14, // 1: SLRouteGlobalStatsGetMsgRsp.ErrStatus:type_name -> SLErrorStatus
	15, // 2: SLVrfRegMsg.Oper:type_name -> SLRegOp
	4,  // 3: SLVrfRegMsg.VrfRegMsgs:type_name -> SLVrfReg
	14, // 4: SLVrfRegMsgRes.ErrStatus:type_name -> SLErrorStatus
	14, // 5: SLVrfRegMsgRsp.StatusSummary:type_name -> SLErrorStatus
	6,  // 6: SLVrfRegMsgRsp.Results:type_name -> SLVrfRegMsgRes
	14, // 7: SLVrfRegGetMsgRsp.ErrStatus:type_name -> SLErrorStatus
	4,  // 8: SLVrfRegGetMsgRsp.Entries:type_name -> SLVrfReg
	14, // 9: SLVRFGetStatsMsgRsp.ErrStatus:type_name -> SLErrorStatus
	10, // 10: SLVRFGetStatsMsgRsp.Entries:type_name -> SLVRFGetStatsMsgRes
	16, // 11: SLRoutePath.NexthopAddress:type_name -> SLIpAddress
	17, // 12: SLRoutePath.NexthopInterface:type_name -> SLInterface
	16, // 13: SLRoutePath.RemoteAddress:type_name -> SLIpAddress
	14, // [14:14] is the sub-list for method output_type
	14, // [14:14] is the sub-list for method input_type
	14, // [14:14] is the sub-list for extension type_name
	14, // [14:14] is the sub-list for extension extendee
	0,  // [0:14] is the sub-list for field type_name
}

func init() { file_sl_route_common_proto_init() }
func file_sl_route_common_proto_init() {
	if File_sl_route_common_proto != nil {
		return
	}
	file_sl_common_types_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_sl_route_common_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRouteGlobalsGetMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRouteGlobalsGetMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRouteGlobalStatsGetMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRouteGlobalStatsGetMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVrfReg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVrfRegMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVrfRegMsgRes); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVrfRegMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVrfRegGetMsg); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVrfRegGetMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVRFGetStatsMsgRes); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLVRFGetStatsMsgRsp); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRouteCommon); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_sl_route_common_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SLRoutePath); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_sl_route_common_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   14,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_sl_route_common_proto_goTypes,
		DependencyIndexes: file_sl_route_common_proto_depIdxs,
		MessageInfos:      file_sl_route_common_proto_msgTypes,
	}.Build()
	File_sl_route_common_proto = out.File
	file_sl_route_common_proto_rawDesc = nil
	file_sl_route_common_proto_goTypes = nil
	file_sl_route_common_proto_depIdxs = nil
}
